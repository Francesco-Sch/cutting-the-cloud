---

---

<script>
	import Konva from "konva";

	let heroContainer = document.querySelector("#hero");

	let hero = new Konva.Stage({
		container: "hero",
		width: heroContainer.offsetWidth,
		height: heroContainer.offsetHeight,
	});

	let bgLayer = new Konva.Layer();
	hero.add(bgLayer);

	Konva.Image.fromURL("/whats-worth_hero.webp", (img) => {
		img.setAttrs({
			x: 0,
			y: 0,
			width: hero.width(),
			height: (hero.width() / img.width()) * img.height(),
			listening: false,
		});

		bgLayer.add(img);
	});

	let gradientLayer = new Konva.Layer();
	hero.add(gradientLayer);

	let gradient = new Konva.Circle({
		x: hero.width() / 2,
		y: hero.height() / 2,
		radius: (hero.width() / 10) * 6,
		fillRadialGradientStartPoint: { x: 0, y: 0 },
		fillRadialGradientStartRadius: 0,
		fillRadialGradientEndPoint: { x: 0, y: 0 },
		fillRadialGradientEndRadius: (hero.width() / 10) * 6,
		fillRadialGradientColorStops: [
			0,
			"#f5f5f5",
			0.1,
			"#f5f5f5f5",
			0.2,
			"#f5f5f5f0",
			0.3,
			"#f5f5f5de",
			0.7,
			"#f5f5f5b5",
			1,
			"#f5f5f500",
		],

		listening: false,
	});
	gradientLayer.add(gradient);

	let thLayer = new Konva.Layer();

	function calculatePosition(index, total, itemSize, spacing) {
		return (itemSize + spacing) * index;
	}

	const imageGrid = [[], [], []]; // Initialize a 3x3 grid
	const gridSize = 3;

	Konva.Image.fromURL("/TH08_frame.webp", (img) => {
		const spacing = 25; // Set the spacing between images
		const outerSpacing = 50; // Set the spacing around the grid
		const availableSize =
			Math.min(hero.width(), hero.height()) -
			2 * outerSpacing -
			(gridSize - 1) * spacing;
		const itemSize = availableSize / gridSize;
		const startX =
			(hero.width() - (availableSize + (gridSize - 1) * spacing)) / 2;
		const startY =
			(hero.height() - (availableSize + (gridSize - 1) * spacing)) / 2;

		for (let row = 0; row < gridSize; row++) {
			for (let column = 0; column < gridSize; column++) {
				let thImg = img.clone({
					x: startX + calculatePosition(column, gridSize, itemSize, spacing),
					y: startY + calculatePosition(row, gridSize, itemSize, spacing),
					width: itemSize,
					height: itemSize,
					listening: false,
				});
				thLayer.add(thImg);
				imageGrid[row][column] = thImg; // Store image object in the grid
			}
		}
	});

	const animLayer = new Konva.Layer();

	function startRingAnimation(intervalTime) {
		setInterval(() => {
			// Choose a random row and column for the ring to appear
			const randomRow = Math.floor(Math.random() * gridSize);
			const randomColumn = Math.floor(Math.random() * gridSize);

			// Get the position and size from the corresponding image in the grid
			const img = imageGrid[randomRow][randomColumn];
			if (!img) return;

			const xPosition = img.x();
			const yPosition = img.y();
			const thSize = img.width();

			// Calculate the center of the image
			const centerX = xPosition + thSize / 2;
			const centerY = yPosition + thSize / 2;

			// Square size
			const sqSize = thSize / 20;

			// Ring parameters
			let outerRadius = 0;
			const innerRadius = 0;

			// Create squares
			for (let y = 0; y < thSize; y += sqSize) {
				for (let x = 0; x < thSize; x += sqSize) {
					const square = new Konva.Rect({
						x: x + xPosition,
						y: y + yPosition,
						width: sqSize,
						height: sqSize,
						fill: "#171717",
						visible: false, // Initially set all squares to invisible
					});
					animLayer.add(square);

					// Calculate distance from center to the square
					const dist = Math.hypot(
						centerX - (x + sqSize / 2),
						centerY - (y + sqSize / 2)
					);

					// If distance is within the ring's radius, make the square visible
					if (dist < outerRadius && dist > innerRadius) {
						square.visible(true);
					}
				}
			}

			// Animation to grow the ring
			const anim = new Konva.Animation((frame) => {
				const children = animLayer.getChildren();
				for (let i = 0; i < children.length; i++) {
					const child = children[i];
					const x = child.x() + sqSize / 2;
					const y = child.y() + sqSize / 2;
					const dist = Math.hypot(centerX - x, centerY - y);

					// Circle to Square Transition
					if (outerRadius <= thSize / 2) {
						if (dist < outerRadius && dist > innerRadius) {
							child.visible(true);
						} else {
							child.visible(false);
						}
					} else {
						const offset = outerRadius - sqSize * 2; // Adjust this value to control the final size
						// Calculate the boundaries for square shape
						const leftBoundary = centerX - offset;
						const rightBoundary = centerX + offset;
						const topBoundary = centerY - offset;
						const bottomBoundary = centerY + offset;

						if (
							x > leftBoundary &&
							x < rightBoundary &&
							y > topBoundary &&
							y < bottomBoundary
						) {
							child.visible(true);
						} else {
							child.visible(false);
						}
					}
				}
				outerRadius += 1;

				if (outerRadius > thSize / 2 + sqSize) {
					// you can adjust this value
					anim.stop();
				}
			}, animLayer);

			anim.start();
		}, intervalTime);
	}

	// Start the ring animation with an interval of 5 seconds
	startRingAnimation(3000);

	hero.add(animLayer);
	hero.add(thLayer);
</script>

<section class="w-full h-screen" id="hero"></section>

<style></style>
